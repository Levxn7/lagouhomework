# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = [];
for(var i = 0; i < 10; i++) {
  a[i] = function() {
    console.log(i)
  }
}
a[6]()
```
答案是: 10
不仅a[6]()的结果是10, a[n]()的结果都是10
程序在每次循环时开辟一个堆地址来放一个匿名函数, 他的作用域是EC(G), 函数体是打印i, 开辟之后执行i++
i是用var声明的, 所以是全局作用域
函数在执行时的作用域链为<EC(AN),EC(G)>, 在当前执行上下文的AO中找不到i, 于是去EC(G)中找i, 此时已经经过了10次自增
所以每个函数的打印都是10

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123;
if (true) {
  console.log(tmp);
  let tmp;
}
```
会报错: Cannot access 'tmp' before initialization
因为let是块级作用域,在变量声明前前无法找到
因var声明会变量提升, 声明前可调用, 值是undefined, 但let与const会直接报错
　
### 3. 结合ES6语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
```
用...将数组展开, 用数学方法取值
```js
var min = Math.min(...arr)
```

### 4. 请详细说明var、let、const三种声明变量的方式之间的具体差别
var let 声明后可变，const常量声明后不可变, 复合类型数据不可变的是储存地址指针，值是可以变的
```js
const obj ={ a: 2}
obj.a = 1
```
let const 是块作用域，var是全局作用域
```js
if(1){
    let a = 1
    var b = 2
}
console.log(b)  //2
console.log(a)  //ReferenceError: a is not defined
```
var 声明会变量提升，声明前可调用，值是undefined，let与const会直接报错
let 与 var 可以先声明后赋值，而const不可以
在同一作用域下，同一变量名，var可重复声明，let const 不行
```js
var a = 2 
var a = 3 //a == 3

let b = 2
let b = 3 // Identifier 'b' has already been declared
```

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10;
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  }
}
obj.fn()
```
答案是: 20
setTimeout是箭头函数, 没有this指向, 只能指向上层的obj

### 6. 简述Symbol类型的用途
symbol是一种全新的原始数据类型, 最主要的作用就是为对象添加独一无二的属性名
```js
const s = Symbol()
Symbol() === Symbol()//值是false,他们不完全相同
```
对象的键可以是symbol, 因为symbol的唯一性, for in 和keys拿不到symbol, 特别作为适合私有属性名
object.getOwnPropertySymbols(obj)可以拿到但只能拿到symbol()类型的
6种基本数据类型+symbol就是7种类型+下一版本的bugInt就是8种数据类型

### 7. 说说什么是浅拷贝，什么是深拷贝？
对于基本数据类型，浅拷贝是对值的复制，对于引用类型来说，浅拷贝是对内存地址的复制，并没有开辟新的栈
也就是浅拷贝的复制的结果是两个对象指向同一个地址，修改其中一个对象的属性，则另一个对象的属性也会改变
而深拷贝则是开辟新的栈，两个对象对应两个不同的地址，修改一个对象的属性，不会改变另一个对象的属性。

实现深拷贝的几个常见的方法:
```js
let result = JSON.parse(JSON.stringify(test))
let result = _.cloneDeep(test)
let result = Object.assign({}, obj); // obj赋值给一个空{}
```
### 8. 请简述TypeScript与JavaScript之间的关系？
Javascript是基于ES6标准进行实现和扩展的
TypeScript可以编译出纯净, 简洁的JavaScript代码, 并且可以运行在任何浏览器上
所以TypeScript是一种由微软开发的自由和开源的编程语言
它是JavaScript的一个超集, 而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程, 是一种给JavaScript添加特性的语言扩展

### 9. 请谈谈你所认为的typescript优缺点
优点: ts的功能强大,生态健全,语言更完善,任何一种js运行环境都支持.
缺点: 语言本身多了很多概念, 不过因为是渐进式很容易上手. 项目初期使用ts还会增加一些成本, 所以更多是用在一些大项目中.

### 10. 描述引用计数的工作原理和优缺点
工作原理:
设置引用数, 判断当前引用数, 引用关系改变时修改引用数字, 引用数字为0时立即回收

优点:
会立即回收垃圾
最大限度减少程序暂停（卡顿）

缺点:
无法回收循环引用的对象（互相引用）
时间开销大（资源消耗大）

### 11. 描述标记整理算法的工作流程
首先知道标记清楚的工作流程:
分标记和清除两个阶段完成
1.遍历所有对象标记活动对象
2.遍历所有对象清除没有被标记的对象
然后回收相应的空间, 放在空闲链表上, 方便以后申请使用

标记整理可以看做是标记清除的增强版
- 标记阶段的操作和标记清除一致
- 清除阶段会先执行整理,移动对象位置

标记整理回收的空间基本是连续的, 不会立即回收垃圾对象

### 12.描述V8中新生代存储区垃圾回收的流程
内存分为新生代和老生代, 新生代指的是存活时间较短的对象

新生代对象回收实现
- 回收过程采用复制算法＋标记整理
- 新生代内存区分为两个等大小空间, 使用空间为From, 空闲空间为To, 活动对象存储于From空间
- 标记整理后将活动对象拷贝至To空间
- From与To交换空间完成释放

### 13. 描述增量标记算法在何时使用及工作原理
将一整段垃圾回收操作分成几个小段
垃圾回收与程序执行交替完成
在V8清除老生代对象时为提高清除效率优化时使用
清除时，程序执行然后遍历对象进行标记，之后交替执行程序和增量标操作，标记完成后，进行清除操作，完成垃圾回收；


　

　